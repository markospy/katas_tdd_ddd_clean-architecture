Perfecto, Marcos üöÄ. Bas√°ndome en lo que hemos trabajado en este chat (Cap√≠tulo 2 y 3 de *Cosmic Python*, abstracciones, repositorios concretos y fakes, inversi√≥n de dependencias, TDD y dominio limpio), aqu√≠ te dejo un **ejercicio estilo kata** para practicar:

---

# ü•ã Kata: Abstracciones y Repositorios en Python

## Contexto

Este ejercicio surge del **Cap√≠tulo 3 de *Cosmic Python***, donde aprendimos que el **dominio no debe depender de implementaciones concretas** como una base de datos. En su lugar, usamos **abstracciones** (interfaces) y luego implementamos repositorios concretos (SQLAlchemy, Fake, etc.).
La idea es ejercitar el **principio de inversi√≥n de dependencias** creando un dominio puro que pueda funcionar con diferentes repositorios.

---

## Instrucciones

1. Define una clase abstracta `AbstractRepository` con los m√©todos necesarios para manejar `Batch` (del cap√≠tulo 1).
2. Implementa un repositorio en memoria (`FakeRepository`) que cumpla con la interfaz.
3. Escribe pruebas unitarias que usen `FakeRepository` para verificar el comportamiento de la funci√≥n de dominio `allocate()`.
4. Implementa un repositorio que simule persistencia en una ‚Äúbase de datos‚Äù muy b√°sica (puede ser solo un diccionario interno).
5. Refactoriza tus tests para que el **dominio no dependa del tipo de repositorio**: deber√≠an correr igual con Fake o con ‚ÄúDBRepo‚Äù.

---

## Restricciones

* Trabaja con **TDD**: primero los tests, luego el c√≥digo.
* No uses librer√≠as externas (solo `abc` y `pytest/unittest`).
* No mezcles l√≥gica de dominio con la l√≥gica de persistencia.

---

## Nivel

**Intermedio**: ya exige comprender abstracciones, repositorios y pruebas aisladas del dominio.

---

## Lenguaje

Python üêç (puedes extender luego a JavaScript si quieres).

---

## Ejemplo inicial

### `model.py` (dominio simplificado)

```python
from dataclasses import dataclass
from typing import Optional

@dataclass(frozen=True)
class OrderLine:
    orderid: str
    sku: str
    qty: int

@dataclass
class Batch:
    reference: str
    sku: str
    purchased_quantity: int
    allocations: set = None

    def __post_init__(self):
        if self.allocations is None:
            self.allocations = set()

    def allocate(self, line: OrderLine) -> bool:
        if self.can_allocate(line):
            self.allocations.add(line)
            return True
        return False

    def can_allocate(self, line: OrderLine) -> bool:
        return self.sku == line.sku and self.available_quantity >= line.qty

    @property
    def available_quantity(self) -> int:
        return self.purchased_quantity - sum(line.qty for line in self.allocations)
```

### `test_repository.py` (punto de partida vac√≠o)

```python
def test_allocate_uses_repository():
    # TODO: implementar
    pass
```

---

## Criterio de √©xito

El programador habr√° resuelto bien el kata si:

* Todos los tests pasan con **FakeRepository** y con el repositorio simulado de ‚Äúbase de datos‚Äù.
* El c√≥digo del dominio (`Batch`, `allocate`) **no conoce ni importa** nada sobre repositorios.
* El dise√±o queda limpio, aplicando el principio de inversi√≥n de dependencias.

---

## Versi√≥n extendida (opcional)

* Implementa un `SqlAlchemyRepository` real usando SQLite en memoria.
* Haz que tu test de dominio pueda ejecutarse indistintamente con **Fake**, **DBRepo** o **SqlAlchemyRepo**.
* Introduce un ‚ÄúService Layer‚Äù sencillo que use el repositorio para procesar √≥rdenes.

---

üëâ ¬øQuieres que preparemos juntos el **esqueleto de `AbstractRepository` y un primer test en TDD** para que empieces a resolver el kata paso a paso?
